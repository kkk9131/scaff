<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>寸法線デモ（インライン版・直開き対応）</title>
    <style>
      html, body { height: 100%; margin: 0; font-family: system-ui, sans-serif; }
      .toolbar { padding: 8px 12px; border-bottom: 1px solid #e5e5e5; display: flex; gap: 12px; align-items: center; }
      .wrap { height: calc(100% - 42px); display: grid; place-items: center; background: #fafafa; }
      svg { background: white; border: 1px solid #ddd; box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
      .edge { stroke: #111; stroke-width: 2; }
      .dim { stroke: #0d6efd; stroke-width: 1.5; fill: none; }
      .label { fill: #0d6efd; font-size: 12px; user-select: none; }
      .handle { fill: #ff6b6b; cursor: grab; }
      .handle:active { cursor: grabbing; }
      input[type='range'] { vertical-align: middle; }
      .hint { color: #666; font-size: 12px; margin-left: 8px; }
    </style>
  </head>
  <body>
    <div class="toolbar">
      <strong>寸法線デモ（インライン版）</strong>
      <span class="hint">ES Modules不使用のため、ファイル直開きでも動作します</span>
      <label>オフセット: <input id="offset" type="range" min="0" max="60" value="16" /></label>
      <label>小数桁: <input id="dec" type="number" min="0" max="3" step="1" value="1" style="width:4em;" /></label>
      <label><input id="leftNormal" type="checkbox" checked /> 外側=左法線</label>
    </div>
    <div class="wrap">
      <svg id="stage" width="800" height="520" viewBox="0 0 800 520"></svg>
    </div>
    <script>
      // --- DimensionEngine（インライン） ---
      function add(p, q) { return { x: p.x + q.x, y: p.y + q.y }; }
      function sub(p, q) { return { x: p.x - q.x, y: p.y - q.y }; }
      function mul(p, s) { return { x: p.x * s, y: p.y * s }; }
      function norm(p) { return Math.hypot(p.x, p.y); }
      function normalize(p) { const n = norm(p); return n === 0 ? { x: 0, y: 0 } : { x: p.x / n, y: p.y / n }; }
      function leftNormal(p) { return { x: -p.y, y: p.x }; }
      function rightNormal(p) { return { x: p.y, y: -p.x }; }
      function distance(a, b) { return Math.hypot(b.x - a.x, b.y - a.y); }
      const DEFAULTS = { outsideIsLeftNormal: true, offset: 16, decimals: 1 };
      class DimensionEngineInline {
        computeForEdges(edges, opts = {}) {
          const cfg = { ...DEFAULTS, ...opts };
          return edges.map((edge) => {
            const v = sub(edge.b, edge.a);
            const n = cfg.outsideIsLeftNormal ? leftNormal(v) : rightNormal(v);
            const u = normalize(n);
            const off = mul(u, cfg.offset);
            const start = add(edge.a, off);
            const end = add(edge.b, off);
            const mid = mul(add(start, end), 0.5);
            const val = Number(distance(edge.a, edge.b).toFixed(cfg.decimals));
            return { start, end, textAnchor: mid, value: val, edgeId: edge.id, offset: cfg.offset, side: 'outside', units: 'px' };
          });
        }
      }

      // --- DimensionRenderer（インライン） ---
      class DimensionRendererInline {
        constructor(svgEl, options = {}) {
          this.svg = svgEl;
          this.options = { showHandles: true, offset: 16, decimals: 1, outsideIsLeftNormal: true, ...options };
          this.engine = new DimensionEngineInline();
          this.points = [];
          this._drag = null;
          this._setupEvents();
        }
        setPoints(points) { this.points = points.map(p => ({ x: p.x, y: p.y })); this.render(); }
        setOptions(options) { this.options = { ...this.options, ...options }; this.render(); }
        getEdges() {
          const edges = [];
          for (let i = 0; i < this.points.length; i++) {
            const a = this.points[i];
            const b = this.points[(i + 1) % this.points.length];
            edges.push({ a, b, id: `e${i}` });
          }
          return edges;
        }
        clear() { while (this.svg.firstChild) this.svg.removeChild(this.svg.firstChild); }
        render() {
          this.clear();
          const edges = this.getEdges();
          edges.forEach(e => this.svg.appendChild(this._line(e.a.x, e.a.y, e.b.x, e.b.y, 'edge')));
          const dims = this.engine.computeForEdges(edges, { offset: this.options.offset, decimals: this.options.decimals, outsideIsLeftNormal: this.options.outsideIsLeftNormal });
          for (const d of dims) {
            this.svg.appendChild(this._line(d.start.x, d.start.y, d.end.x, d.end.y, 'dim'));
            const label = `${d.value.toFixed(this.options.decimals)} ${d.units ?? 'px'}`;
            this.svg.appendChild(this._text(d.textAnchor.x, d.textAnchor.y - 4, label, 'label'));
          }
          if (this.options.showHandles) {
            this.points.forEach((p, idx) => {
              const h = this._circle(p.x, p.y, 6, 'handle');
              h.dataset.idx = String(idx);
              this.svg.appendChild(h);
            });
          }
        }
        _line(x1, y1, x2, y2, cls) {
          const el = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          el.setAttribute('x1', x1); el.setAttribute('y1', y1);
          el.setAttribute('x2', x2); el.setAttribute('y2', y2);
          if (cls) el.setAttribute('class', cls);
          // 直接属性でもスタイルを指定（CSSが反映されない環境の保険）
          if (cls === 'edge') { el.setAttribute('stroke', '#111'); el.setAttribute('stroke-width', '2'); }
          if (cls === 'dim') { el.setAttribute('stroke', '#0d6efd'); el.setAttribute('stroke-width', '1.5'); el.setAttribute('fill', 'none'); }
          return el;
        }
        _circle(cx, cy, r, cls) { const el = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); el.setAttribute('cx', cx); el.setAttribute('cy', cy); el.setAttribute('r', r); if (cls) el.setAttribute('class', cls); return el; }
        _text(x, y, content, cls) { const el = document.createElementNS('http://www.w3.org/2000/svg', 'text'); el.setAttribute('x', x); el.setAttribute('y', y); if (cls) el.setAttribute('class', cls); el.textContent = content; el.setAttribute('fill', '#0d6efd'); return el; }
        _setupEvents() {
          this.svg.addEventListener('pointerdown', (e) => {
            const target = e.target;
            if (target && target.classList && target.classList.contains('handle')) {
              this._drag = { idx: Number(target.dataset.idx), pointerId: e.pointerId };
              target.setPointerCapture(e.pointerId);
            }
          });
          this.svg.addEventListener('pointermove', (e) => {
            if (!this._drag) return;
            const idx = this._drag.idx;
            const pt = this.svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY;
            const ctm = this.svg.getScreenCTM(); if (!ctm) return;
            const loc = pt.matrixTransform(ctm.inverse());
            this.points[idx].x = loc.x; this.points[idx].y = loc.y; this.render();
          });
          this.svg.addEventListener('pointerup', () => { this._drag = null; });
          this.svg.addEventListener('pointercancel', () => { this._drag = null; });
        }
      }

      // --- 起動処理 ---
      const stage = document.getElementById('stage');
      const renderer = new DimensionRendererInline(stage, { showHandles: true });
      const points = [ { x: 200, y: 160 }, { x: 500, y: 160 }, { x: 500, y: 360 }, { x: 200, y: 360 } ];
      renderer.setPoints(points);
      const offset = document.getElementById('offset');
      const dec = document.getElementById('dec');
      const leftNormal = document.getElementById('leftNormal');
      offset.addEventListener('input', () => renderer.setOptions({ offset: Number(offset.value) }));
      dec.addEventListener('input', () => renderer.setOptions({ decimals: Number(dec.value) }));
      leftNormal.addEventListener('change', () => renderer.setOptions({ outsideIsLeftNormal: leftNormal.checked }));
    </script>
  </body>
  </html>
